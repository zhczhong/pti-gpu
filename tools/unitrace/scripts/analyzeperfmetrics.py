#==============================================================
# Copyright (C) Intel Corporation
#
# SPDX-License-Identifier: MIT
# =============================================================

#!/usr/bin/env python3

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages as pdf

from http.server import HTTPServer, ThreadingHTTPServer, BaseHTTPRequestHandler
from urllib.parse import unquote

import os
import io
import socket
import ssl
import sys
import re
import subprocess
import argparse
import tempfile

def ParseArguments():
    argparser = argparse.ArgumentParser(description = "GPU Kernel Performance Hardware Metrics Analyzer")
    argparser.add_argument('-l', '--list', action = 'store_true', help = "list devices, metrics and kernels in the input performance metric data file")
    argparser.add_argument('-d', '--device', type = int, default = 0, help = "GPU device (device 0 by default)")
    argparser.add_argument('-k', '--kernel', help = "kernel name with shape, all kernels if this option is not specified")
    argparser.add_argument('-i', '--instance', type = int, default = 1, help = "kernel instance. all instances if < 1 (1 or the first instance by default)")
    argparser.add_argument('-m', '--metrics', action = 'append', help = "list of comma-separated metric names")
    argparser.add_argument('-b', '--bandwidth', action = 'append', help = "list of comma-separated metric names for bandwidth")
    argparser.add_argument('-o', '--output', help = "output file in text format if -l is present, PDF format regardless of file extension if -k is not present or if instance < 1")
    argparser.add_argument('-p', '--https', action = 'store_true', help = "start https server")
    argparser.add_argument('-c', '--certificate', help = "certificate file for https server")
    argparser.add_argument('-e', '--key', help = "private key file for https server")
    argparser.add_argument('-s', '--shaderdump', help = "shader dump folder for stall analysis")
    argparser.add_argument('-r', '--report', help = "stall analysis report in plain text")
    argparser.add_argument('-y', '--ylabel', action = 'append', help = "label for Y axis")
    argparser.add_argument('-x', '--xlabel', default = "Time(in sampling intervals)", help = "label for X axis (defaut is \"Time(in sampling intervals)\")")
    argparser.add_argument('-t', '--title', default = "Performance Metrics", help = "performance metric plot title")
    argparser.add_argument('input', help = 'hardware performance metric data file in .csv format generated by unitrace -k/--stall-sampling')

    return argparser.parse_args()

def Demangle(name):
    cxxfilt = ['c++filt']
    cxxfilt.append(name)

    p = subprocess.Popen(cxxfilt, stdin = subprocess.PIPE, stdout = subprocess.PIPE, text = True)
    stdout, _ = p.communicate()
    demangled = stdout.split("\n")[0]

    if ("typeinfo name for" not in demangled):   # name is not mangled
        return name
    else:
        return demangled[18:]	#skip leading "typeinfo name for "

class BB:
    def __init__(self, bid, start, end, preds, succs):
        self.bid = bid
        self.start = start
        self.end = end
        self.preds = preds
        self.succs = succs

    def in_bb(self, ins):	# is ins in this basic block
        if ((ins >= self.start) and (ins <= self.end)):
            return True
        else:
            return False

    def get_bid(self): # get basic block id
        return self.bid

    def get_preds(self): # get predecessors
        return self.preds

    def get_head(self):	# get basic lock head instruction address
        return self.start

    def get_tail(self):	# get basic block tail instruction address
        return self.end


def ConstructCFG(instructions):
    bb_head = None
    in_bb = False
    bb_id = None
    preds = []
    succs = []
    bbs = dict()
    for addr, ins in enumerate(instructions):
        if ((re.match("// *B", ins) is not None) and ("Preds" in ins) and ("Succs" in ins)):
            if (in_bb):	# previous bb ends
                bb = BB(bb_id, bb_head, addr - 1, preds, succs)
                bbs[bb_id] = bb
            in_bb = True
            bb_head = addr
            bb_id = ins.split(" ")[1].split(":")[0].strip()
            preds = []
            for b in ins.split("Preds")[1].split("{")[1].split("}")[0].split(","):
                if (b.strip() != ""):
                    preds.append(b.strip())

            succs = []
            for b in ins.split("Succs")[1].split("{")[1].split("}")[0].split(","):
                if (b.strip() != ""):
                    succs.append(b.strip())

    # don't forget the last bb
    if (in_bb):
        bb = BB(bb_id, bb_head, len(instructions) - 1, preds, succs)
        bbs[bb_id] = bb

    if (len(bbs) == 0):	# at least one BB exits
        bb = BB("B000", 0, len(instructions) - 1, [], [])
        bbs["B000"] = bb	# dummy basic block id "B000"

    return bbs

def FindBB(bbs, ins):	# find BB of an instruction
    for bb_id, bb in bbs.items():
        if (bb.in_bb(ins)):
            return bb_id, bb

    return None, None	# never reaches here

def AnalyzeStalls(kernel, args, stalldf):
    shaders = os.listdir(args.shaderdump)
    files = []	# .asm files

    for f in shaders:
        if f.endswith(".asm"):
            files.append(args.shaderdump + "/" + f)

    asmfiles = []
    for f in files:
        with open(f, "r") as inf:
            for row in inf:
                if row.startswith("//.kernel"):
                    kname = row.split()[1]
                    kname = Demangle(kname)
                    if (kernel == kname):
                        asmfiles.append(f)

    if (len(asmfiles) == 0):
        msg = "Not found .asm file for " + kernel
        print(msg)
        return msg

    asm = asmfiles[0]
    if (len(asmfiles) > 1):	# kernel has been retried, found the latest one
        # find the longest name length
        # the latest one has the longest name
        max_asm_file_name_len = 0
        for f in asmfiles:
            if (len(f) > max_asm_file_name_len):
                max_asm_file_name_len = len(f)
                asm = f
        # find the largest name in alphabetical order
        # the latest one has the largest name
        for f in asmfiles:
            if (len(f) == max_asm_file_name_len):
                if (asm < f):
                    asm = f

    ip = 0
    addressed = True
    with open(asm, "r") as inf:
        for row in inf:
            if ((row.startswith("//") == False) and ("//" in row)):
                if (row.startswith("/* [" + str('{:08X}'.format(ip)) + "] */ ") == False):	# no ip in asm
                    addressed = False
                if ("Compacted" in row):
                    ip = ip + 0x8
                else:
                    ip = ip + 0x10

    if (addressed == False):	# add ip addresses
        ip = 0
        with open(asm, "r") as inf:
            with open(asm + ".ip", "w") as outf:
                for row in inf:
                    if ((row.startswith("//") == False) and ("//" in row)):
                        outf.write("/* [" + str('{:08X}'.format(ip)) + "] */ " + row)
                        if ("Compacted" in row):
                            ip = ip + 0x8
                        else:
                            ip = ip + 0x10
                    else:
                        outf.write(row)

        asm = asm + ".ip"

    source_available = False
    instructions = []
    with open(asm, "r") as inf:
        for row in inf:
            ins = row.split("\n")
            if (len(ins) > 0):
                instructions.append(ins[0])
            else:
                instructions.append("")
            if (re.match("// *Line", row) is not None):
                source_available = True

    bbs = ConstructCFG(instructions)

    df = stalldf[["IP[Address]", "SbidStall[Events]"]]
    df = df[df["SbidStall[Events]"] > 0]	# drop 0s
    df = df.sort_values(by = ["SbidStall[Events]"], ascending = False)

    report = "Kernel: " + kernel + "\n"
    report += "Assembly with instruction addresses: " + asm + "\n"
    report += "***********************************************************************************************\n"
    report += "Sbid Stalls: \n"

    for index, row in df.iterrows():
        ip = row["IP[Address]"]
        pc = int(ip, 16)
        for addr, ins in enumerate(instructions):
            if ((ins.startswith("//") == False) and ("//" in ins)):
                if (ins.startswith("/* [" + str('{:08X}'.format(pc))+ "] */ ") == True):	# found stalled instruction
                    words = ins.split("{")
                    sbids_stalled = []
                    if (len(words) >= 2):
                        for token in words[1].split("}")[0].split(","):
                            if (token.startswith("$") == True):
                                if (("load" in ins) or ("store" in ins) or ("send" in ins) or ("EOT" in ins)):
                                    if (len(token.split(".")) > 1): # .src or .dst
                                        sbids_stalled.append(token)
                                else:
                                    sbids_stalled.append(token)
                    if (len(sbids_stalled) == 0):
                        words = ins.split("(")	# check if SBID tokens are in (...)
                        if (len(words) >= 2):
                            i = 1
                            done = False
                            while (done == False):
                                for token in words[i].split(")")[0].split(","):
                                    if (token.startswith("$") == True):
                                        if (("load" in ins) or ("store" in ins) or ("send" in ins) or ("EOT" in ins)):
                                            if (len(token.split(".")) > 1): # .src or .dst
                                                sbids_stalled.append(token)
                                        else:
                                            sbids_stalled.append(token)
                                        done = True
                                i = i + 1
                                if (i == len(words)):	# all words are inspected
                                    break

                    ins_stalled_not_line_resolved = addr
                    ins_stalled_not_file_resolved = addr
                    ins_stall_not_line_resolved = []
                    ins_stall_not_file_resolved = []
                    source_line_stalled = None
                    source_file_stalled = None
                    source_lines_stall = dict()
                    source_files_stall = dict()

                    bbid, bb = FindBB(bbs, addr)
                    bbs_to_check = [(bbid, bb.get_head(), addr - 1)]	# instrction at addr is the instruction stalled
                    j = 0
                    done = False
                    while (done == False):
                        if (len(bbs_to_check) <= j):
                            break
                        bid, start, end = bbs_to_check[j]
                        break_at = end
                        for addr2, ins2 in enumerate(reversed(instructions[start : end + 1])):
                            if (len(sbids_stalled) > 0):
                                if ((ins2.startswith("//") == False) and ("//" in ins2) and (re.match("/\* *\[", ins2) is not None)):
                                    tokens = ins2.split("{")
                                    if (len(tokens) > 1):
                                        sbids_stall = []
                                        for token in tokens[1].split("}")[0].split(","):
                                            if (token.startswith("$") == True):
                                                sbids_stall.append(token)
                                        for sbid in sbids_stalled:
                                            for sbid2 in sbids_stall:
                                                if (len(sbid.split(".")) > 1): # .dst or .src in bid
                                                    if (sbid2 == sbid.split(".")[0]):
                                                        sbids_stalled.remove(sbid)	# remove sbid from the sbids of the instruction stalled
                                                        ins_stall_not_line_resolved.append(end - addr2)	# source lines/files to be resolved
                                                        ins_stall_not_file_resolved.append(end - addr2)
                                                else:
                                                    if (sbid == sbid2.split(".")[0]): # stalled ins depends on ins2 or dependency already resolved
                                                        if ((sbid == sbid2) and ("sync." not in ins2)): # ins2 not a sync. ins depends on ins2
                                                            sbids_stalled.remove(sbid)	# remove sbid from the sbids of the instruction stalled
                                                            ins_stall_not_line_resolved.append(end - addr2) # source lines/files to be resolved
                                                            ins_stall_not_file_resolved.append(end - addr2)

                            if (re.match("// *Line", ins2) is not None):
                                if (ins_stalled_not_line_resolved != None): # source line of stalled instruction
                                    source_line_stalled = end - addr2
                                    ins_stalled_not_line_resolved = None

                                for i in ins_stall_not_line_resolved:
                                    source_lines_stall[i] = end - addr2
                                ins_stall_not_line_resolved.clear()

                            if (re.match("// *File", ins2) is not None):
                                if (ins_stalled_not_file_resolved != None): # source file of stalled instruction
                                    source_file_stalled = end - addr2
                                    ins_stalled_not_file_resolved = None

                                for i in ins_stall_not_file_resolved:
                                    source_files_stall[i] = end - addr2
                                ins_stall_not_file_resolved.clear()

                            if (len(sbids_stalled) == 0):
                                if (source_available == False):
                                    done = True
                                else:
                                    if ((ins_stalled_not_line_resolved == None) and (ins_stalled_not_file_resolved == None)):
                                        if ((len(ins_stall_not_line_resolved) == 0) and (len(ins_stall_not_file_resolved) == 0)):
                                            done = True

                                break_at = end - addr2
                                break

                        if (done == False):
                            if (len(sbids_stalled) == 0):
                                # scan backward for source line and file
                                for addr3, ins3 in enumerate(reversed(instructions[0 : break_at])):
                                    if (re.match("// *Line", ins3) is not None):
                                        if (ins_stalled_not_line_resolved != None): # source line of stalled instruction
                                            source_line_stalled = break_at - 1 - addr3
                                            ins_stalled_not_line_resolved = None

                                        for i in ins_stall_not_line_resolved:
                                            source_lines_stall[i] = break_at - 1 - addr3
                                        ins_stall_not_line_resolved.clear()

                                    if (re.match("// *File", ins3) is not None):
                                        if (ins_stalled_not_file_resolved != None): # source file of stalled instruction
                                            source_file_stalled = break_at - 1 - addr3
                                            ins_stalled_not_file_resolved = None

                                        for i in ins_stall_not_file_resolved:
                                            source_files_stall[i] = break_at - 1 - addr3
                                        ins_stall_not_file_resolved.clear()

                                done = True
                                break
                            else:
                                for b in bbs[bid].get_preds():
                                    bb = bbs[b]
                                    bbs_to_check.append((b, bb.get_head(), bb.get_tail()))
                        else:
                            break

                        j = j + 1

                    report += "\nInstruction\n"
                    report += "  " + ins + "\n";
                    if (source_line_stalled != None):
                        report += "  " + instructions[source_line_stalled][3:] + "\n"
                        if (source_file_stalled != None):
                            report += "  " + instructions[source_file_stalled][3:] + "\n"

                    if ((len(source_lines_stall) > 0) or (len(ins_stall_not_line_resolved) > 0)):
                        report += "is stalled potentially by\n"
                        for i, line in source_lines_stall.items():
                            report += "  instruction\n"
                            report += "    " + instructions[i] + "\n"
                            report += "    " + instructions[line][3:] + "\n"
                            if (i in source_files_stall):
                                report += "    " + instructions[source_files_stall[i]][3:] + "\n"
                            else:
                                report += "    File: unknown\n"
                        for i in ins_stall_not_line_resolved:
                            report += "  instruction\n"
                            report += "    " + instructions[i] + "\n"
                    else:
                        report += "is stalled\n"

                    break


    # analyze stalls of other types

    type = ["ControlStall[Events]", "PipeStall[Events]", "SendStall[Events]", "DistStall[Events]", "SyncStall[Events]", "InstrFetchStall[Events]", "OtherStall[Events]"]
    for t in type:
        df = stalldf[["IP[Address]", t]]
        df = df[df[t] > 0]	# drop 0s
        if (df.shape[0] == 0):	# zero stalls. move to the next type
            continue
        df = df.sort_values(by = [t], ascending = False)

        report += "***********************************************************************************************\n"
        report += t.split("Stall")[0] + " Stalls: \n"

        for index, row in df.iterrows():
            ip = row["IP[Address]"]
            pc = int(ip, 16)
            for addr, ins in enumerate(instructions):
                if ((ins.startswith("//") == False) and ("//" in ins)):
                    if (ins.startswith("/* [" + str('{:08X}'.format(pc))+ "] */ ") == True):	# found stalled instruction
                        if (source_available == True):
                            ins_stalled_not_line_resolved = addr
                            ins_stalled_not_file_resolved = addr
                            source_line_stalled = None
                            source_file_stalled = None

                            for addr2, ins2 in enumerate(reversed(instructions[0: addr])):
                                if (re.match("// *Line", ins2) is not None):
                                    if (ins_stalled_not_line_resolved != None): # source line of stalled instruction
                                        source_line_stalled = addr - 1 - addr2
                                        ins_stalled_not_line_resolved = None

                                if (re.match("// *File", ins2) is not None):
                                    if (ins_stalled_not_file_resolved != None): # source file of stalled instruction
                                        source_file_stalled = addr - 1 - addr2
                                        ins_stalled_not_file_resolved = None

                                if ((ins_stalled_not_line_resolved == None) and (ins_stalled_not_file_resolved == None)):
                                    break	# we are done

                        report += "\nInstruction\n"
                        report += "  " + ins + "\n"
                        if (source_line_stalled != None):
                            report += "  " + instructions[source_line_stalled][3:] + "\n"
                            if (source_file_stalled != None):
                                report += "  " + instructions[source_file_stalled][3:] + "\n"

                        report += "is stalled\n"

                        break

    report += "===============================================================================================\n"
    return report

def WriteOutStallReport(report, p): # p is PDF object
    if (p is None): # p should already be created, but just in case
        return  # do nothing

    lines = report.split('\n')
    page = ""
    num = 0
    page_size = 48  # number of lines per page
    line_width = 160 # number of characters per line
    font_size = 4
    for line in lines:
        if (len(line) == 0):    # empty line
            line = "\n"
        s = 0
        while (len(line[s:]) > line_width):
            page += line[s:s + line_width]
            page += '\n'
            num += 1
            if (num == page_size):
                fig = plt.figure()
                plt.axis('off')
                page = page.replace('$', '\$')  # escape '$'
                plt.text(0.0, 0.0, page, fontsize = font_size, ha = 'left', wrap = True)
                fig.savefig(p, format = 'pdf')
                plt.close(fig) # close figure
                page = ""  # reset for next page
                num = 0
            s += line_width
        if (s < len(line)):
            page += line[s:]
            page += '\n'
            num += 1
            if (num == page_size):
                fig = plt.figure()
                plt.axis('off')
                page = page.replace('$', '\$')
                plt.text(0.0, 0.0, page, fontsize = font_size, ha = 'left', wrap = True)
                fig.savefig(p, format = 'pdf')
                plt.close(fig) # close figure
                page = ""  # reset for next page
                num = 0
            
    # don't forget the last page
    if (num != 0):
        fig = plt.figure()
        plt.axis('off')
        page = page.replace('$', '\$')
        plt.text(0.0, 0.0, page, fontsize = font_size, ha = 'left', wrap = True)
        fig.savefig(p, format = 'pdf')
        plt.close(fig) # close figure

    return

def AnalyzeStallMetrics(args, header, last, kernel, http = False):

    if ((http == True) and (kernel is None)):
        return None, None

    buf = None
    stall_analysis_report_out = None
    if (args.shaderdump is not None):
        if (os.path.isdir(args.shaderdump) == False):
            msg = "Shader dump folder " + args.shaderdump + " does not exist"
            if (http == False):
                print(msg)
            return msg, None
        if ((http == False) and (args.report is not None)):
            stall_analysis_report_out = open(args.report, "w")

    # only read lines from headerlinenumber to lastline
    df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)

    stalls = ["ControlStall[Events]", "PipeStall[Events]", "SendStall[Events]", "DistStall[Events]", "SbidStall[Events]", "SyncStall[Events]", "InstrFetchStall[Events]", "OtherStall[Events]"]

    ins_per_page = 100  # number of instuctions to histogram per page
    if (kernel is None):    # http is False
        # all kernels
        start = 0
        stop = -1
        kernel = ""
        p = None
        for index, row in df.iterrows():
            if (kernel == ""):
                kernel = row['Kernel']
                start = index
            else:
                if (kernel != row['Kernel']):
                    stop = index
                    df2 = df[start:stop]    # data frame of the kernel of interest
                    # remove rows with 0 stall events
                    df2 = df2.loc[(df2["ControlStall[Events]"] != 0) | (df2["PipeStall[Events]"] != 0) | (df2["SendStall[Events]"] != 0) | (df2["DistStall[Events]"] != 0) | (df2["SbidStall[Events]"] != 0) | (df2["SyncStall[Events]"] != 0) | (df2["InstrFetchStall[Events]"] != 0) | (df2["OtherStall[Events]"] != 0)]
                    df3 = df2[stalls]

                    if (df3.shape[0] > 0):
                        xlabels = []
                        xticks = []
                        for i, ip in enumerate(df2["IP[Address]"]):
                            xlabels.append(ip)
                            xticks.append(i)

                        df3 = df3.reset_index()
                        numpages = (df3.shape[0] + (ins_per_page - 1)) // ins_per_page # multiple charts if more than ins_per_page instructions are stalled
                        if (numpages > 1):
                            for page in range(1, numpages + 1):
                                df4 = df3[ins_per_page * (page - 1) : min([ins_per_page * page, df3.shape[0]])]
                                if (df4.shape[0] > 1):
                                    ax = df4.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                                else:
                                    ax = df4.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                                ax.set_xticks(xticks[ins_per_page * (page - 1) :  min([ins_per_page * page, df3.shape[0]])], labels = xlabels[ins_per_page * (page - 1) :  min([ins_per_page * page, df3.shape[0]])], rotation = 90, fontsize = 4)
                                plt.grid(visible = True, which = 'both', axis = 'y')
                                plt.legend(loc = 'best', fontsize = 4)
                                plt.title(label = args.title + "\n(" + kernel + ")(" + str(page) + "/" + str(numpages) + ")", loc = 'center', fontsize = 8, wrap = True)
                                plt.tight_layout()
                                fig = ax.get_figure()
                                if (p == None):
                                    p = pdf(args.output)
                                fig.savefig(p, format = 'pdf')
                                plt.close(fig)	# close figure to save memory
                        else:
                            if (df3.shape[0] > 1):	# draw line chart if there are at least 2 data points
                                ax = df3.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                            else:	# draw bar chart otherwise
                                ax = df3.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                            ax.set_xticks(xticks, labels = xlabels, rotation = 90, fontsize = 4)
                            plt.grid(visible = True, which = 'both', axis = 'y')
                            plt.legend(loc = 'best', fontsize = 4)
                            plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                            plt.tight_layout()
                            fig = ax.get_figure()
                            if (p == None):
                                p = pdf(args.output)
                            fig.savefig(p, format = 'pdf')
                            plt.close(fig)	# close figure to save memory

                        if (args.shaderdump is not None):
                            report = AnalyzeStalls(kernel, args, df2)
                            if (stall_analysis_report_out is not None):
                                print(report, file = stall_analysis_report_out)
                            if (p == None):
                                p = pdf(args.output)
                            WriteOutStallReport(report, p)
            
                        print("\nAnalyzed kernel " + kernel)
                    else:
                        print("\nNo stall events for kernel " + kernel)

                    kernel = row['Kernel']
                    start = index

        # last kernel
        stop = df.shape[0]
        df2 = df[start : stop]    # data frame of the kernel of interest

        # remove rows with 0 stall events
        df2 = df2.loc[(df2["ControlStall[Events]"] != 0) | (df2["PipeStall[Events]"] != 0) | (df2["SendStall[Events]"] != 0) | (df2["DistStall[Events]"] != 0) | (df2["SbidStall[Events]"] != 0) | (df2["SyncStall[Events]"] != 0) | (df2["InstrFetchStall[Events]"] != 0) | (df2["OtherStall[Events]"] != 0)]
        df3 = df2[stalls]

        if (df3.shape[0] > 0):
            xlabels = []
            xticks = []
            for i, ip in enumerate(df2["IP[Address]"]):
                xlabels.append(ip)
                xticks.append(i)

            df3 = df3.reset_index()
            numpages = (df3.shape[0] + (ins_per_page - 1)) // ins_per_page  # multiple charts if more than ins_per_page instructions are stalled
            if (numpages > 1):
                for page in range(1, numpages + 1):
                    df4 = df3[ins_per_page * (page - 1) : min([ins_per_page * page, df3.shape[0]])]
                    if (df4.shape[0] > 1):
                        ax = df4.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                    else:
                        ax = df4.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                    ax.set_xticks(xticks[ins_per_page * (page - 1) :  min([ins_per_page * page, df3.shape[0]])], labels = xlabels[ins_per_page * (page - 1) :  min([ins_per_page * page, df3.shape[0]])], rotation = 90, fontsize = 4)
                    plt.grid(visible = True, which = 'both', axis = 'y')
                    plt.legend(loc = 'best', fontsize = 4)
                    plt.title(label = args.title + "\n(" + kernel + ")(" + str(page) + "/" + str(numpages) + ")", loc = 'center', fontsize = 8, wrap = True)
                    plt.tight_layout()
                    fig = ax.get_figure()
                    if (p == None):
                        p = pdf(args.output)
                    fig.savefig(p, format = 'pdf')
                    plt.close(fig)	# close figure to save memory
            else:
                if (df3.shape[0] > 1):
                    ax = df3.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                else:
                    ax = df3.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)

                ax.set_xticks(xticks, labels = xlabels, rotation = 90, fontsize = 4)
                plt.grid(visible = True, which = 'both', axis = 'y')
                plt.legend(loc = 'best', fontsize = 4)
                plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                plt.tight_layout()
                fig = ax.get_figure()
                if (p == None):
                    p = pdf(args.output)
                fig.savefig(p, format = 'pdf')
                plt.close(fig)	# close figure to save memory

            if (args.shaderdump is not None):
                report = AnalyzeStalls(kernel, args, df2)
                if (stall_analysis_report_out is not None):
                    print(report, file = stall_analysis_report_out)
                if (p == None):
                    p = pdf(args.output)
                WriteOutStallReport(report, p)

            print("\nAnalyzed kernel " + kernel)
        else:
            print("\nNo stall events for kernel " + kernel)

        if (p != None):
            p.close()
            print("\nStall metric charts are stored in file " + args.output + " in PDF format")

        if ((args.shaderdump is not None) and (args.report is not None) and (stall_analysis_report_out is not None)):
            stall_analysis_report_out.close()
            print("Stall report is also stored in file " + args.report)

    else:
        counting = True
        start = -1
        stop = -1
        kernelfound = False

        for index, row in df.iterrows():
            if (row['Kernel'] == kernel):
                if (kernelfound == False):
                    start = index
                    kernelfound = True
            else:
                if (kernelfound == True):
                    stop = index
                    break

        if (kernelfound == False):
            msg = "No metric data for kernel " + kernel
            if (http == False):
                print(msg)
            return msg, None

        if (stop == -1):
            stop = df.shape[0]

        df2 = df[start : stop]    # data frame of the kernel of interest

        # remove rows with 0 stall events
        df2 = df2.loc[(df2["ControlStall[Events]"] != 0) | (df2["PipeStall[Events]"] != 0) | (df2["SendStall[Events]"] != 0) | (df2["DistStall[Events]"] != 0) | (df2["SbidStall[Events]"] != 0) | (df2["SyncStall[Events]"] != 0) | (df2["InstrFetchStall[Events]"] != 0) | (df2["OtherStall[Events]"] != 0)]
        df3 = df2[stalls]

        if (df3.shape[0] > 0):
            xlabels = []
            xticks = []
            for i, ip in enumerate(df2["IP[Address]"]):
                xlabels.append(ip)
                xticks.append(i)

            df3 = df3.reset_index()
            numpages = (df3.shape[0] + (ins_per_page - 1)) // ins_per_page # multiple charts if more than ins_per_page instructions are stalled
            p = None
            if (http == False):
                p = pdf(args.output)
            else:
                tmpdir = tempfile.TemporaryDirectory()
                tmpfile = os.path.join(tmpdir.name, "stallchart.pdf")
                p = pdf(tmpfile)

            if (numpages > 1):
                for page in range(1, numpages + 1):
                    df4 = df3[ins_per_page * (page - 1) : min([ins_per_page * page, df3.shape[0]])]
                    if (df4.shape[0] > 1):
                        ax = df4.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                    else:
                        ax = df4.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                    ax.set_xticks(xticks[ins_per_page * (page - 1) :  min([ins_per_page * page, df3.shape[0]])], labels = xlabels[ins_per_page * (page - 1) :  min([ins_per_page * page, df3.shape[0]])], rotation = 90, fontsize = 4)
                    plt.grid(visible = True, which = 'both', axis = 'y')
                    plt.legend(loc = 'best', fontsize = 4)
                    plt.title(label = args.title + "\n(" + kernel + ")(" + str(page) + "/" + str(numpages) + ")", loc = 'center', fontsize = 8, wrap = True)
                    plt.tight_layout()
                    fig = ax.get_figure()
                    fig.savefig(p, format = 'pdf')
                    plt.close(fig)	# close figure to save memory
            else:
                if (df3.shape[0] > 1):
                    ax = df3.plot(y = stalls, kind = 'line', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                else:
                    ax = df3.plot(y = stalls, kind = 'bar', xlabel = "IP[Address]", ylabel = "Events", fontsize = 6)
                ax.set_xticks(xticks, labels = xlabels, rotation = 90, fontsize = 4)
                plt.grid(visible = True, which = 'both', axis = 'y')
                plt.legend(loc = 'best', fontsize = 4)
                plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                plt.tight_layout()
                fig = ax.get_figure()
                fig.savefig(p, format = 'pdf')
                plt.close(fig)

            if (args.shaderdump is not None):
                report = AnalyzeStalls(kernel, args, df2)
                if ((http == False) and (stall_analysis_report_out is not None)):
                    print(report, file = stall_analysis_report_out)
                WriteOutStallReport(report, p)

            if (p != None):
                p.close()

            if (http == True):
                buf = io.BytesIO()
                fp = open(tmpfile, "rb")
                buf.write(fp.read())
                fp.close()
                os.remove(tmpfile)
                tmpdir.cleanup()

            if (http == False):
                print("\nStall metric chart in file " + args.output + " has been successfully generated.")
        else:
            print("\nNo stall events for kernel " + kernel + " in the input data")

        if ((http == False) and (args.shaderdump is not None) and (args.report is not None) and (stall_analysis_report_out is not None)):
            stall_analysis_report_out.close()
            print("Stall report is also stored in file " + args.report)

    return None, buf

def PlotKernelInstancePerfMetrics(args, kernel, df, metric_sets_cleansed, bandwidths_sets_cleansed, p):
    k = 0
    counting = True
    start = -1
    stop = -1
    instancefound = False

    for index, row in df.iterrows():
        if (pd.isna(row['Kernel']) == False):
            if ((row['Kernel'] == kernel) and (counting == True)):
                k = k + 1			# found kernel of interest
                counting = False		# set to false so this block will not enter again for this instance
                if (k == args.instance):	# found instance of interest
                    start = index
                    instancefound = True
        else:
            counting = True			# a new kernel and/or a new instance starts in the data frame
            if (instancefound == True):
                stop = index
                break

    if ((instancefound == True) and (stop == -1)):	# the instance of interest is at the end of data frame
        stop = df.shape[0]

    if (instancefound == False):
        print("No metric data for instance " + str(args.instance) + " of kernel " + kernel)
        return False, p

    df2 = df[start : stop]	# data frame of the instance of interest
    analyzed = False
    for metrics_cleansed, label in zip(metric_sets_cleansed, args.ylabel):
        df3 = df2[metrics_cleansed]

        if (df3.shape[0] > 0):
            if (df3.shape[0] > 1):
                ax = df3.plot(y = metrics_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = label)
            else:
                ax = df3.plot(y = metrics_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = label)
            plt.grid(visible = True, which = 'both', axis = 'y')
            plt.legend(loc = 'best', fontsize = 4)
            plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
            plt.tight_layout()
            if (p == None):
                p = pdf(args.output)
            fig = ax.get_figure()
            fig.savefig(p, format = 'pdf')
            plt.close(fig)	# close figure to save memory
            analyzed = True
        else:
            break

    if (analyzed == True):
        for bandwidths_cleansed in bandwidths_sets_cleansed:
            df3 = df2[bandwidths_cleansed]
            df3 = (df3.iloc[:, 1:]).div(df3.iloc[:, 0], axis = 0)
    
            if (df3.shape[0] > 0):
                if (df3.shape[0] > 1):
                    ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'line', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
                else:
                    ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'bar', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
    
                plt.grid(visible = True, which = 'both', axis = 'y')
                plt.legend(loc = 'best', fontsize = 4)
                plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                plt.tight_layout()
                if (p == None):
                    p = pdf(args.output)
                fig = ax.get_figure()
                fig.savefig(p, format = 'pdf')
                plt.close(fig)	# close figure to save memory

            else:
                break
    
    return analyzed, p

def AnalyzePerfMetrics(args, header, last):

    # only read lines from headerlinenumber to lastline
    df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)

    metric_sets_cleansed = []
    for metric_set in args.metrics:
        metrics = metric_set.split(sep = ',')
        metrics_cleansed = []
        for metric in metrics:
            me = metric.strip()			# strip off leading and trailing whitespaces
            if (me not in df.columns):
                print("No metric data for " + metric)
                return
            else:
                metrics_cleansed.append(me)
        metric_sets_cleansed.append(metrics_cleansed)

    bandwidths_sets_cleansed = []
    if (args.bandwidth is not None):
        for bandwidth_set in args.bandwidth:
            bandwidths = bandwidth_set.split(sep = ',')
            bandwidths_cleansed = ['GpuTime[ns]']
            for bandwidth in bandwidths:
                bw = bandwidth.strip()			# strip off leading and trailing whitespaces
                if (bw not in df.columns):
                    print("No bandwidth data for " + bw)
                    return
                else:
                    bandwidths_cleansed.append(bw)
            bandwidths_sets_cleansed.append(bandwidths_cleansed)

    p = None
    if (args.kernel is None):
        if (args.instance < 1):
            # all kernels and all instances
            start = 0
            stop = -1
            kernel = ""
            for index, row in df.iterrows():
                if (pd.isna(row['Kernel']) == True):
                    stop = index	# current kernel instance ends

                    df2 = df[start : stop]	# data frame of the instance of interest
                    analyzed = False
                    for metrics_cleansed, label in zip(metric_sets_cleansed, args.ylabel):
                        df3 = df2[metrics_cleansed]
                        if (df3.shape[0] > 0):
                            if (df3.shape[0] > 1):
                                ax = df3.plot(y = metrics_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = label)
                            else:
                                ax = df3.plot(y = metrics_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = label)
    
                            plt.grid(visible = True, which = 'both', axis = 'y')
                            plt.legend(loc = 'best', fontsize = 4)
                            plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                            plt.tight_layout()
                            if (p == None):
                                p = pdf(args.output)
                            fig = ax.get_figure()
                            fig.savefig(p, format = 'pdf')
                            plt.close(fig)	# close figure to save memory
                            analyzed = True
                        else:
                            break

                    if (analyzed == True):
                        for bandwidths_cleansed in bandwidths_sets_cleansed:
                            df3 = df2[bandwidths_cleansed]
                            df3 = (df3.iloc[:, 1:]).div(df3.iloc[:, 0], axis = 0)
    
                            if (df3.shape[0] > 0):
                                if (df3.shape[0] > 1):
                                    ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'line', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
                                else:
                                    ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'bar', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
        
                                plt.grid(visible = True, which = 'both', axis = 'y')
                                plt.legend(loc = 'best', fontsize = 4)
                                plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                                plt.tight_layout()
                                if (p == None):
                                    p = pdf(args.output)
                                fig = ax.get_figure()
                                fig.savefig(p, format = 'pdf')
                                plt.close(fig)	# close figure to save memory
                                analyzed = True
                            else:
                                break
    
                        print("Analyzed kernel " + kernel)
                    else:
                        print("No samples for kernel " + kernel)

                    kernel = ""	# reset kernel name to empty
                else:
                    if (kernel == ""):
                        start = index	# a new kernel instance starts
                        kernel = row['Kernel']

        else:
            # specified instance of all kernels
            kernels = df['Kernel'].unique()
            for kernel in kernels:
                if (pd.isna(kernel) == True):
                    continue

                analyzed, p = PlotKernelInstancePerfMetrics(args, kernel, df, metric_sets_cleansed, bandwidths_sets_cleansed, p)
                if (analyzed == True):
                    print("Analyzed kernel " + kernel)

    else:
        if (args.instance < 1):
            # specified kernel all instances
            counting = True
            start = -1
            stop = -1
            instance = 0
            for index, row in df.iterrows():
                if (pd.isna(row['Kernel']) == False):
                    if ((row['Kernel'] == args.kernel) and (counting == True)):
                        start = index			# found kernel of interest
                        counting = False		# set to false so this block will not enter again for this instance
                else:
                    if (counting == False):
                        # instance ends
                        stop = index
                        df2 = df[start : stop]	# data frame of the instance of interest
                        analyzed = False
                        for metrics_cleansed, label in zip(metric_sets_cleansed, args.ylabel):
                            df3 = df2[metrics_cleansed]

                            instance = instance + 1
                            if (df3.shape[0] > 0):
                                if (df3.shape[0] > 1):
                                    ax = df3.plot(y = metrics_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = label)
                                else:
                                    ax = df3.plot(y = metrics_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = label)

                                plt.grid(visible = True, which = 'both', axis = 'y')
                                plt.legend(loc = 'best', fontsize = 4)
                                plt.title(label = args.title + "\n(" + args.kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                                plt.tight_layout()
                                if (p == None):
                                    p = pdf(args.output)
                                fig = ax.get_figure()
                                fig.savefig(p, format = 'pdf')
                                plt.close(fig)	# close figure to save memory
                                analyzed = True
                            else:
                                break

                        if (analyzed):
                            for bandwidths_cleansed in bandwidths_sets_cleansed:
                                df3 = df2[bandwidths_cleansed]
                                df3 = (df3.iloc[:, 1:]).div(df3.iloc[:, 0], axis = 0)
        
                                if (df3.shape[0] > 0):
                                    if (df3.shape[0] > 1):
                                        ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'line', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
                                    else:
                                        ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'bar', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
            
                                    plt.grid(visible = True, which = 'both', axis = 'y')
                                    plt.legend(loc = 'best', fontsize = 4)
                                    plt.title(label = args.title + "\n(" + args.kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                                    plt.tight_layout()
                                    if (p == None):
                                        p = pdf(args.output)
                                    fig = ax.get_figure()
                                    fig.savefig(p, format = 'pdf')
                                    plt.close(fig)	# close figure to save memory
                                    analyzed = True
                                else:
                                    break
    
                            print("Analyzed instance " + str(instance) + " of kernel " + args.kernel)
                        else:
                            print("No samples for instance " + str(instance) + " of kernel " + args.kernel)

                        # continue scan for next instance
                        counting = True			# a new kernel and/or a new instance starts in the data frame
                        start = -1
                        stop = -1

            if ((start != -1) and (stop == -1)):	# the instance of interest is at the end of data frame
                stop = df.shape[0]

                df2 = df[start : stop]	# data frame of the instance of interest
                analyzed = False
                for metrics_cleansed, label in zip(metric_sets_cleansed, args.ylabel):
                    df3 = df2[metrics_clenased]

                    instance = instance + 1
                    if (df3.shape[0] > 0):
                        if (df3.shape[0] > 1):
                            ax = df3.plot(y = metric_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = label)
                        else:
                            ax = df3.plot(y = metric_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = label)

                        plt.grid(visible = True, which = 'both', axis = 'y')
                        plt.legend(loc = 'best', fontsize = 4)
                        plt.title(label = args.title + "\n(" + args.kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                        plt.tight_layout()
                        if (p == None):
                            p = pdf(args.output)
                        fig = ax.get_figure()
                        fig.savefig(p, format = 'pdf')
                        plt.close(fig)	# close figure to save memory
                        analyzed = True
                    else:
                        break

                if (analyzed == True):
                    for bandwidths_cleansed in bandwidths_sets_cleansed:
                        df3 = df2[bandwidths_cleansed]
                        df3 = (df3.iloc[:, 1:]).div(df3.iloc[:, 0], axis = 0)
    
                        if (df3.shape[0] > 0):
                            if (df3.shape[0] > 1):
                                ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'line', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
                            else:
                                ax = df3.plot(y = bandwidths_cleansed[1:], kind = 'bar', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
    
                            plt.grid(visible = True, which = 'both', axis = 'y')
                            plt.legend(loc = 'best', fontsize = 4)
                            plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                            plt.tight_layout()
                            if (p == None):
                                p = pdf(args.output)
                            fig = ax.get_figure()
                            fig.savefig(p, format = 'pdf')
                            plt.close(fig)	# close figure to save memory
                            analyzed = True
                        else:
                            break

                    print("Analyzed instance " + str(instance) + " of kernel " + args.kernel)
                else:
                    print("No samples for " + str(instance) + " of kernel " + args.kernel)

        else:
            # specified kernel specified instance
            analyzed, p = PlotKernelInstancePerfMetrics(args, args.kernel, df, metric_sets_cleansed, bandwidths_sets_cleansed, p)
            if (analyzed == True):
                print("Performance metric chart for instance " + str(args.instance) + " of kernel " + args.kernel + " hsa been successfully generated")
            else:
                print("No performance data for instance " + str(args.instance) + " of kernel " + args.kernel)

    if (p != None):
        p.close()
        print("Performance metric charts are successfully generated in PDF format")
    else:
        print("No performance metric data for kernel or kernel instance")


def List(args):
    devices = []
    with open(args.input, "r") as f:
        linenum = 0
        counting = False
        for row in f:
            if (("=== Device" in row) and ("Metrics ===" in row)):
                words = row.split()
                for word in words:
                    if (word[0] == '#'):
                        device = word[1:]
                        devices.append(int(device))

    of = sys.stdout
    if (args.output is not None):
        of = open(args.output, "w")

    for device in devices:
        header = 0
        device_banner = "=== Device #" + str(device) + " Metrics ==="
        last = 0
        devicefound = False
        eustall = False
        with open(args.input, "r") as f:
            linenum = 0
            counting = False
            for row in f:
                if (("=== Device" in row) and ("Metrics ===" in row)):
                    if (device_banner in row):		# found device
                        counting = True
                        devicefound = True
                    else:
                        if (devicefound == True):	# done with the device of interest
                            break
                if (counting == True):
                    if (("OtherStall[Events]," in row) or (row.startswith("Kernel,"))):      # found header
                        header = linenum
                        counting = False
                        if ("OtherStall[Events]," in row):
                            eustall = True
                linenum += 1

            last = linenum

        print("Device " + str(device), file = of)
        # only read lines from headerlinenumber to lastline
        df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)
        print("    Metric", file = of)

        if (eustall == False):
            for m in df.columns.values.tolist():
                if (m == 'Kernel'):
                    continue
                print("        " + m, file = of)
                if (m == 'StreamMarker'):
                    break

            kernel_and_instances = dict()
            kernel = ""
            for index, row in df.iterrows():
                if (pd.isna(row['Kernel']) == True):
                    if kernel in kernel_and_instances:
                        kernel_and_instances[kernel] = kernel_and_instances[kernel] + 1
                    else:
                        if (kernel != ""):
                            kernel_and_instances[kernel] = 1

                    kernel = ""	# reset kernel name to empty
                else:
                    if (kernel == ""):
                        kernel = row['Kernel']

            print("    Kernel, Number of Instances", file = of)
            for i, (kernel, instances) in enumerate(kernel_and_instances.items()):
                print("        \"" + kernel + "\", " + str(instances), file = of)
        else:
            for m in df.columns.values.tolist():
                if (m == 'Kernel' or m == "IP[Address]"):
                    continue
                print("        " + m, file = of)
                if (m == 'OtherStall[Events]'):
                    break

            kernels = []
            for index, row in df.iterrows():
                kernel = row['Kernel']
                if (kernel not in kernels):
                    kernels.append(kernel)

            print("    Kernel", file = of)
            for kernel in kernels:
                print("        \"" + kernel + "\"", file = of)

    if (args.output is not None):
        of.close()

def HttpAnalyzeStallMetrics(args, header, last, kname):
    return AnalyzeStallMetrics(args, header, last, kname, http = True)

def HttpAnalyzePerfMetrics(args, header, last, kname, instance):
    df = pd.read_csv(args.input, skiprows = header, nrows = last - header - 1, skip_blank_lines = False, skipinitialspace = True)
    df = df.loc[df['GlobalInstanceId'] == float(instance)]
    if (df.shape[0] == 0):
        return None, None
    
    buf = None
    metric_sets_cleansed = []
    for metric_set in args.metrics:
        metrics = metric_set.split(sep = ',')
        metrics_cleansed = []
        for metric in metrics:
            me = metric.strip()			# strip off leading and trailing whitespaces
            if (me not in df.columns):
                msg = "No metric data for " + metric + ". Is the metric name correctly spelled?"
                return msg, None
            else:
                metrics_cleansed.append(me)
        metric_sets_cleansed.append(metrics_cleansed)

    bandwidths_sets_cleansed = []
    if (args.bandwidth is not None):
        for bandwidth_set in args.bandwidth:
            bandwidths = bandwidth_set.split(sep = ',')
            bandwidths_cleansed = ['GpuTime[ns]']
            for bandwidth in bandwidths:
                bw = bandwidth.strip()			# strip off leading and trailing whitespaces
                if (bw not in df.columns):
                    msg = "No metric data for " + bw + ". Is the metric name correctly spelled?"
                    return msg, None
                else:
                    bandwidths_cleansed.append(bw)
            bandwidths_sets_cleansed.append(bandwidths_cleansed)


    p = None
    for metrics_cleansed, label in zip(metric_sets_cleansed, args.ylabel):
        df2 = df[metrics_cleansed]
        
        if (df2.shape[0] > 0):
            if (df2.shape[0] > 1):
                ax = df2.plot(y = metrics_cleansed, kind = 'line', xlabel = args.xlabel, ylabel = label)
            else:
                ax = df2.plot(y = metrics_cleansed, kind = 'bar', xlabel = args.xlabel, ylabel = label)
            plt.grid(visible = True, which = 'both', axis = 'y')
            plt.legend(loc = 'best', fontsize = 4)
            kernel = df.iloc[0]['Kernel']
            plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
            plt.tight_layout()
        
            fig = ax.get_figure()
            if (p == None):
                tmpdir = tempfile.TemporaryDirectory()
                tmpfile = os.path.join(tmpdir.name, "perfchart.pdf")
                p = pdf(tmpfile)
            fig.savefig(p, format = 'pdf')
            plt.close(fig)  # close figure to save memory
        else:
            break

    if (p != None):
        for bandwidths_cleansed in bandwidths_sets_cleansed:
            df2 = df[bandwidths_cleansed]
            df2 = (df2.iloc[:, 1:]).div(df2.iloc[:, 0], axis = 0)
            if (df2.shape[0] > 0):
                if (df2.shape[0] > 1):
                    ax = df2.plot(y = bandwidths_cleansed[1:], kind = 'line', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
                else:
                    ax = df2.plot(y = bandwidths_cleansed[1:], kind = 'bar', xlabel = args.xlabel, ylabel = 'Bandwidth(GB/s)')
    
                plt.grid(visible = True, which = 'both', axis = 'y')
                plt.legend(loc = 'best', fontsize = 4)
                plt.title(label = args.title + "\n(" + kernel + ")", loc = 'center', fontsize = 8, wrap = True)
                plt.tight_layout()
                fig = ax.get_figure()
                fig.savefig(p, format = 'pdf')
                plt.close(fig)	# close figure to save memory
            else:
                break

        p.close()
        buf = io.BytesIO()
        fp = open(tmpfile, "rb")
        buf.write(fp.read())
        fp.close()
        os.remove(tmpfile)
        tmpdir.cleanup()

    return None, buf 
    

def GenerateSelfSignedCertificate(cert, key):
    # construct command to generate a self-signed certificate and private key
    command = ["openssl", "req", "-x509", "-newkey", "rsa:2048", "-keyout", key, "-out", cert, "-days", "365", "-nodes", "-subj", "/CN=localhost"]

    try:
        subprocess.run(command, check = True)
        print(f"Self-signed certificate and private key have been generated.")
    except subprocess.CalledProcessError as e:
        print(f"Error occurred while generating self-signed certificate: {e}", file = sys.stderr)

def PerfMetricsHTTPServer(args):
    try:
        sections = []
        with open(args.input, "r") as f:
            linenum = 0
            header = 0
            devicefound = False
            eustall = False
            for row in f:
                if (("OtherStall[Events]," in row) or (row.startswith("Kernel,"))):      # found header
                    header = linenum
                    if ("OtherStall[Events]," in row):
                        eustall = True
                if (("=== Device" in row) and ("Metrics ===" in row)):
                    if (devicefound == False):		# found device
                        devicefound = True
                    else:
                        if (devicefound == True):	# done with the device of interest
                            sections.append([header, linenum])
                            devicefound = False
                linenum += 1

            sections.append([header, linenum])

        class PerfMetricsRequestHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                if (self.client_address[0] != "127.0.0.1"):
                    return

                request = unquote(self.path).split("/")  # format is name/instance
                if (request[1] == "favicon.ico"): # ignore
                    return

                self.send_response(200)
                if (len(request) < 3):
                    self.send_header('Content-type', 'text/plain')
                    self.end_headers()
                    self.wfile.write(b'Invalid')
                    return

                kname = request[1].strip('"')   # strip leading and trailing double quotes
                instance = request[2]

                if ((instance == "") or (instance.isdigit() == False)):
                    self.send_header('Content-type', 'text/plain')
                    self.end_headers()
                    self.wfile.write(b'Invalid')
                    return

                if (eustall == True):   # strip kernel shape for stall sampling
                    pos = kname.rfind('[')
                    if (pos != -1):
                        kname = kname[0:pos]

                msg = None
                buf = None
                for sec in sections:
                    # only read lines from headerlinenumber to lastline

                    last = sec[1]
                    header = sec[0]
                    if (eustall == True):
                        msg, buf = HttpAnalyzeStallMetrics(args, header, last, kname)
                    else:
                        msg, buf = HttpAnalyzePerfMetrics(args, header, last, kname, instance)

                    if (buf is not None):
                        buf.seek(0)
                        try:
                            self.send_header('Content-type', 'application/pdf')
                            self.end_headers()
                            self.wfile.write(buf.read())
                        except BrokenPipeError:
                            print("Try again please")
                        finally:
                            return
                    else:
                        if (msg is not None):
                            break

                self.send_header('Content-type', 'text/plain')
                self.end_headers()
                if (msg is not None):
                    self.wfile.write(bytes(msg, 'utf-8'))
                else:
                    self.wfile.write(b'No metric data collected')

        cert = args.certificate
        key = args.key
        tmpdir = None
        if ((cert == None) and (key == None)):
            # generate a self signed certificate
            print("No certificate or private key is provided.")
            print("Generating a self-signed certificate...")
            tmpdir = tempfile.TemporaryDirectory()
            cert = os.path.join(tmpdir.name, "selfsigned.crt")
            key = os.path.join(tmpdir.name, "private.key")
            GenerateSelfSignedCertificate(cert, key)
        else:
            if (cert is None):
                print("Certificate file is missing")
                return
            if (key is None):
                print("Private key file is missing")
                return

            if (os.path.isfile(cert) == False):
                print("Certificate file " + cert + " does not exist")
                return
            if (os.path.isfile(key) == False):
                print("Private key file " + key + " does not exist")
                return

        httpd = ThreadingHTTPServer(('localhost', 8000), PerfMetricsRequestHandler)

        context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
        context.load_cert_chain(cert, key)
        httpd.socket = context.wrap_socket(httpd.socket, server_side = True)
        if (tmpdir is not None):
            tmpdir.cleanup()
        httpd.serve_forever()

    except KeyboardInterrupt:
        print("Goodbye!")
        return

def main(args):
    if (os.path.isfile(args.input) == False):
        print("File " + args.input + " does not exist or cannot be opened")
        return

    if (os.stat(args.input).st_size ==0):
        print("File " + args.input + " is empty")
        return

    if (args.list == True):
        List(args)
        return

    if (args.https == True):
        print("No output to file")
        print("Options -o/--output, -r/--report, -k/--kernel, -i/--instance and -d/--device are ignored if they are present")
        PerfMetricsHTTPServer(args)
        return

    if (args.output is None):
        print("Error: -o/--output is missing")
        return

    header = 0
    device_banner = "=== Device #" + str(args.device) + " Metrics ==="
    last = 0
    devicefound = False
    eustall = False
    with open(args.input, "r") as f:
        linenum = 0
        counting = False
        for row in f:
            if (("=== Device" in row) and ("Metrics ===" in row)):
                if (device_banner in row):		# found device
                    counting = True
                    devicefound = True
                else:
                    if (devicefound == True):	# done with the device of interest
                        break
            if (counting == True):
                if (("OtherStall[Events]," in row) or (row.startswith("Kernel,"))):      # found header
                    header = linenum
                    counting = False
                    if ("OtherStall[Events]," in row):
                        eustall = True
            linenum += 1

        last = linenum;

    if (devicefound == False):
        print("Device " + str(args.device) + " not found in input file")
        return

    if (eustall == False):
        if (args.metrics is None):
            print("-m option is missing")
            return
        if (args.ylabel is None):
            print("-y option is missing")
            return
        if (len(args.metrics) != len(args.ylabel)):
            print("Numbers of -m options and -y options do not match")
            return
        AnalyzePerfMetrics(args, header, last)
    else:
        AnalyzeStallMetrics(args, header, last, args.kernel)

if __name__== "__main__":
    main(ParseArguments())
